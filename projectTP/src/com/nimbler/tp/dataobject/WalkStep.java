/*
 * 
 */
package com.nimbler.tp.dataobject;



/**
 * Represents one instruction in walking directions. Three examples from New York City:
 * <p>
 * Turn onto Broadway from W 57th St (coming from 7th Ave): <br/>
 * distance = 100 (say) <br/>
 * walkDirection = RIGHT <br/>
 * streetName = Broadway <br/>
 * everything else null/false <br/>
 * </p><p>
 * Now, turn from Broadway onto Central Park S via Columbus Circle <br/>
 * distance = 200 (say) <br/>
 * walkDirection = CIRCLE_COUNTERCLOCKWISE <br/>
 * streetName = Central Park S <br/>
 * exit = 1 (first exit) <br/>
 * immediately everything else false <br/>
 * </p><p>
 * Instead, go through the circle to continue on Broadway <br/>
 * distance = 100 (say) <br/>
 * walkDirection = CIRCLE_COUNTERCLOCKWISE <br/>
 * streetName = Broadway <br/>
 * exit = 3 <br/>
 * stayOn = true <br/>
 * everything else false <br/>
 * </p>
 * */
public class WalkStep {

	/**
	 * The distance in meters that this step takes.
	 */
	private double distance = 0;

	/** 
	 * The relative direction of this step.
	 */
	private RelativeDirection relativeDirection;
	/**
	 * The name of the street.
	 */
	private String streetName;

	/**
	 * The absolute direction of this step. 
	 */
	private AbsoluteDirection absoluteDirection;

	/**  
	 * When exiting a highway or traffic circle, the exit name/number.
	 */

	private String exit;
	/**
	 * Indicates whether or not a street changes direction at an intersection.
	 */
	private Boolean stayOn = false;

	/**
	 * The name of this street was generated by the system, so we should only display it once, and 
	 * generally just display right/left directions
	 */
	private Boolean bogusName = false;

	/**
	 * The longitude of start of the step
	 */
	private double lon;
	/**
	 * The latitude of start of the step
	 */
	private double lat;

	/**
	 * The elevation profile as a comma-separated list of x,y values. 
	 * x is the distance from the start of the step, y is the elevation at this distance.
	 */
	private String elevation;
	private Integer index;

	//	@XmlElement
	//	public List<Alert> alerts;

	public void setDirections(double lastAngle, double thisAngle, boolean roundabout) {
		relativeDirection = getRelativeDirection(lastAngle, thisAngle, roundabout);
		setAbsoluteDirection(thisAngle);
	}

	public String toString() {
		String direction = absoluteDirection.toString();
		if (relativeDirection != null) {
			direction = relativeDirection.toString();
		}
		return "WalkStep(" + direction + " on " + streetName + " for " + distance + ")";
	}

	public static RelativeDirection getRelativeDirection(double lastAngle, double thisAngle, boolean roundabout) {

		double angleDiff = thisAngle - lastAngle;
		if (angleDiff < 0) {
			angleDiff += Math.PI * 2;
		}
		double ccwAngleDiff = Math.PI * 2 - angleDiff;

		if (roundabout) {
			// roundabout: the direction we turn onto it implies the circling direction
			if (angleDiff > ccwAngleDiff) {
				return RelativeDirection.CIRCLE_CLOCKWISE; 
			} else {
				return RelativeDirection.CIRCLE_COUNTERCLOCKWISE;
			}            
		}

		// less than 0.3 rad counts as straight, to simplify walking instructions
		if (angleDiff < 0.3 || ccwAngleDiff < 0.3) {
			return RelativeDirection.CONTINUE;
		} else if (angleDiff < 0.7) {
			return RelativeDirection.SLIGHTLY_RIGHT;
		} else if (ccwAngleDiff < 0.7) {
			return RelativeDirection.SLIGHTLY_LEFT;
		} else if (angleDiff < 2) {
			return RelativeDirection.RIGHT;
		} else if (ccwAngleDiff < 2) {
			return RelativeDirection.LEFT;
		} else if (angleDiff < Math.PI) {
			return RelativeDirection.HARD_RIGHT;
		} else {
			return RelativeDirection.HARD_LEFT;
		}
	}

	private void setAbsoluteDirection(double thisAngle) {
		int octant = (int) (8 + Math.round(thisAngle * 8 / (Math.PI * 2))) % 8;
		absoluteDirection = AbsoluteDirection.values()[octant];
	}

	public double getDistance() {
		return distance;
	}

	public void setDistance(double distance) {
		this.distance = distance;
	}

	public RelativeDirection getRelativeDirection() {
		return relativeDirection;
	}

	public void setRelativeDirection(RelativeDirection relativeDirection) {
		this.relativeDirection = relativeDirection;
	}

	public AbsoluteDirection getAbsoluteDirection() {
		return absoluteDirection;
	}

	public void setAbsoluteDirection(AbsoluteDirection absoluteDirection) {
		this.absoluteDirection = absoluteDirection;
	}

	public String getExit() {
		return exit;
	}

	public void setExit(String exit) {
		this.exit = exit;
	}

	public Boolean getStayOn() {
		return stayOn;
	}

	public void setStayOn(Boolean stayOn) {
		this.stayOn = stayOn;
	}

	public Boolean getBogusName() {
		return bogusName;
	}

	public void setBogusName(Boolean bogusName) {
		this.bogusName = bogusName;
	}

	public double getLon() {
		return lon;
	}

	public void setLon(double lon) {
		this.lon = lon;
	}

	public double getLat() {
		return lat;
	}

	public void setLat(double lat) {
		this.lat = lat;
	}

	public String getElevation() {
		return elevation;
	}

	public void setElevation(String elevation) {
		this.elevation = elevation;
	}

	public Integer getIndex() {
		return index;
	}

	public void setIndex(Integer index) {
		this.index = index;
	}
}
